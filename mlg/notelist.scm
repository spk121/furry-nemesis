(define-module (mlg notelist)
  :use-module (srfi srfi-1)
  :use-module (srfi srfi-11)
  :use-module (rnrs io ports)
  :use-module (mlg binports)
  :use-module (ice-9 pretty-print)
  :use-module (ice-9 optargs)
  :export (
           note-time
           note-duration
           note-channel
           note-key
           note-patch
           note-percussion
           note-velocity-begin
           note-velocity-end

           MidiEvents->NoteList
           NormalizeNoteListTimes!))

;; The final information for a note, after all the mergin, is this...
(define (note-time n) (list-ref n 0))
(define (note-duration n) (list-ref n 1))
(define (note-key n) (list-ref n 2))
(define (note-patch n) (list-ref n 3))
(define (note-percussion n) (list-ref n 4))
(define (note-velocity-begin n) (list-ref n 5))
(define (note-velocity-end n) (list-ref n 6))

(define (set-note-time! n v)
  (list-set! n 0 v))
(define (set-note-duration! n v)
  (list-set! n 1 v))

;; We'll use the term 'tone generator' for the structure that stores
;; a note for which an ON has been received, but no OFF yet.
;; The Track+Key combination is a unique identifier for a tone generator.

;; TG assoc list
;; 0. hashKey
;; 1. track
;; 2. key
;; 3. patch
;; 4. start_time
;; 5. percussion
;; 6. velocity

(define (make-tg-hash track key)
  (logior (ash track 8) key))
(define (tg-time x) (first x))
(define (tg-key x) (second x))
(define (tg-patch x) (third x))
(define (tg-percussion x) (fourth x))
(define (tg-velocity x) (fifth x))

(define (MidiEvents->NoteList midiEvents)
  "Given a MIDI events list as generated by ParseMidi(), 
search for pairs of NOTE_ON and NOTE_OFF events and convert them
to a list of notes with durations.  Also, look for PROGRAM_CHANGE
events that assign instruments."

  (define (_IsNoteOn x)
    (eqv? 'NOTE_ON (car x)))
  (define (_IsNoteOff x)
    (eqv? 'NOTE_OFF (car x)))
  (define (_IsProgramChange x)
    (eqv? 'PROGRAM_CHANGE (car x)))
  (define (_IsAllNotesOff x)
    (eqv? 'ALL_NOTES_OFF (car x)))

  (let (;; Current instrument for each channel
        [_patch (make-list 16 0)]
        ;; List of note-started events
        [toneList '()]
        ;; Return value
        [noteList '()])
    (do ([i 0 (1+ i)]) ([= i (length midiEvents)])
      (let ([event (list-ref midiEvents i)])
        (cond
         ;; FIXME: handle ALL_NOTES_OFF here.
         [(or (_IsNoteOn event) (_IsNoteOff event))
          (let-keywords (cdr event) #t (time track channel key velocity)
                        (if (and (_IsNoteOn event) (> velocity 0))
                            (set! toneList
                                  (assoc-set! toneList (make-tg-hash track key)
                                              (list time
                                                    key
                                                    (list-ref _patch channel) ; last PROGRAM_CHANGE instrument received
                                                    (eqv? channel 9) ; channel 9 is percussion
                                                    velocity)))
                            ;; else OFF event
                            (let ([tonegen (assoc-ref toneList (make-tg-hash track key))])
                              (when tonegen
                                    (set! noteList
                                          (append
                                           noteList
                                           (list
                                            (list
                                             (tg-time tonegen)
                                             (- time (tg-time tonegen)) ; duration
                                             key
                                             (tg-patch tonegen)
                                             (tg-percussion tonegen)
                                             (tg-velocity tonegen) ; start velocity
                                             velocity              ; end velocity
                                             ))))
                                    (set! toneList
                                          (assoc-remove! toneList (make-tg-hash track key)))))))]

         [(_IsProgramChange event)
          (let-keywords (cdr event) #t (channel patch)
                        (list-set! _patch channel patch))])))
    noteList))

(define (NormalizeNoteListTimes! noteList ticksPerQuarterNote tempoMap)
  "Given a note list as generated by MidiEvents->NoteList and a tempo
map as generated by MidiEvents->TempoMap, this modifies the times in
noteList from MIDI ticks to microseconds."
  (define (_GetMicrosecondsPerQuarterNote tick)
    ;; Since tempoMap is an ordered list of pairs where the key is the
    ;; tick where a new tempo is used, we find a pair of entries in
    ;; the list that bracket the current tick, and then use the
    ;; value.
    (do ([i 1 (1+ i)])
        ([or (= i (length tempoMap)) (< tick (car (list-ref tempoMap i)))]
         (cdr (list-ref tempoMap (1- i))))))
  
  (for-each
   (lambda (note)
     (let* ([time (note-time note)]
            [duration (note-duration note)]
            [msPerQ (_GetMicrosecondsPerQuarterNote time)]
            [msPerTick (exact->inexact (/ msPerQ ticksPerQuarterNote))])
       ;; (format #t "time ~a duration ~a msPerQ ~a msPerTick ~a new time ~a new duration ~a~%"
       ;;         time duration msPerQ msPerTick (* time msPerTick 1e-6) (* duration msPerTick 1e-6))
       (set-note-time! note (* time msPerTick 1e-6))
       (set-note-duration! note (* duration msPerTick 1e-6))))
   noteList))

